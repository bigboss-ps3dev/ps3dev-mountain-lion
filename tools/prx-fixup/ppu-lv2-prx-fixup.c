//based on sprxlinker base code. 
//This code can fix elf made by sony gcc 4.1.1 (only for --stub-fix-only option in original command ppu-lv2-prx-fixup)
//in: elf file made by sony gcc 4.1.1 without calling original ppu-lv2-prx-fixup tool
//out: the same elf file fixed 
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>

#include <libelf.h>

#define ELFOSABI_CELLLV2 102

#if defined(_WIN32)
#define OFLAGS		(O_RDWR|O_BINARY)
#else
#define OFLAGS		(O_RDWR)
#endif

#ifdef __BIG_ENDIAN__
#define BE16(num) (num)
#define BE32(num) (num)
#define BE64(num) (num)
#else
#define BE16(num) ((uint16_t)(((uint16_t)((num) << 8)) | (uint8_t)((num) >> 8)))
#define BE32(num) ((uint32_t)((uint32_t)BE16(num) << 16) | BE16(num >> 16))
#define BE64(num) ((uint64_t)((uint64_t)BE32(num) << 32ULL) | BE32(num >> 32ULL))


#endif
#define fileoffset(num) ((uint32_t) ((((num & 0x000F0000)>>16)-1)<<16)|(uint32_t)(num & 0xFFF0FFFF))

typedef struct _sceResident
{
	uint32_t zero;
	char *name;
} __attribute__((packed)) SceResident;

typedef struct _debug
{
	uint32_t stub_head;
	uint32_t name;
	uint32_t fnid;
	uint32_t function;
	uint32_t index;
} __attribute__((packed)) Debug;

typedef struct _stub
{
	uint32_t header1;
	uint16_t header2;
	uint16_t imports;
	uint32_t zero1;
	uint32_t zero2;
	uint32_t name;
	uint32_t fnid;
	uint32_t stub;
	uint32_t zero3;
	uint32_t zero4;
	uint32_t zero5;
	uint32_t zero6;
} __attribute__((packed)) Stub;

typedef struct _opd64
{
	uint64_t func;
	uint64_t rtoc;
	uint64_t data;
} __attribute__((packed)) Opd64;




Elf_Scn* getSection(Elf *elf,const char *name)
{
	Elf64_Ehdr *ehdr = elf64_getehdr(elf);
	if(!ehdr) return NULL;

	Elf_Data *data = elf_getdata(elf_getscn(elf,ehdr->e_shstrndx),NULL);
	if(!data) return NULL;

	for(Elf_Scn *scn = NULL;(scn = elf_nextscn(elf,scn));) {
		Elf64_Shdr *shdr = elf64_getshdr(scn);
		if(shdr && !strcmp(name,(const char*)data->d_buf + shdr->sh_name)) return scn;
	}
	return NULL;
}

void set_ehdr(int fd,Elf64_Ehdr *ehdr)
{
	Elf64_Ehdr new_hdr;

	memcpy(&new_hdr,ehdr,sizeof(Elf64_Ehdr));

	new_hdr.e_type		= BE16(new_hdr.e_type);
	new_hdr.e_machine	= BE16(new_hdr.e_machine);
	new_hdr.e_version	= BE32(new_hdr.e_version);
	new_hdr.e_entry		= BE64(new_hdr.e_entry);
	new_hdr.e_phoff		= BE64(new_hdr.e_phoff);
	new_hdr.e_shoff		= BE64(new_hdr.e_shoff);
	new_hdr.e_flags		= BE32(new_hdr.e_flags);
	new_hdr.e_ehsize	= BE16(new_hdr.e_ehsize);
	new_hdr.e_phentsize	= BE16(new_hdr.e_phentsize);
	new_hdr.e_phnum		= BE16(new_hdr.e_phnum);
	new_hdr.e_shentsize	= BE16(new_hdr.e_shentsize);
	new_hdr.e_shnum		= BE16(new_hdr.e_shnum);
	new_hdr.e_shstrndx	= BE16(new_hdr.e_shstrndx);

	lseek(fd,0,SEEK_SET);
	if(write(fd,&new_hdr,sizeof(Elf64_Ehdr))!=sizeof(Elf64_Ehdr)) {
		printf("Error occurred during write in %s:%d\n",__FILE__,__LINE__);
	}
}

int main(int argc,char *argv[])
{
	if(argc<2) {
		printf("Usage: %s [elf path]\n",argv[0]);
		return 0;
	}

	int fd = open(argv[1],OFLAGS);
	if(fd<0) {
		fprintf(stderr,"Unable to open elf file: %s\n",argv[1]);
		return 1;
	}
	
	elf_version(EV_CURRENT);
	
	Elf *elf = elf_begin(fd,ELF_C_READ,NULL);
	if(!elf) {
		fprintf(stderr,"libelf could not read elf file: %s\n",elf_errmsg(elf_errno()));
		return 1;
	}

	Elf64_Ehdr *ehdr = elf64_getehdr(elf);
	//.psp_libgen_markfun is generated by Sony toolchain we must fix some things
	Elf_Scn *libgen = getSection(elf,".psp_libgen_markfunc");
	//Elf_Scn *libgen = getSection(elf,".debug_libgenfunc");
	   
	Elf_Data *libgendata = elf_getdata(libgen,NULL);
	Debug *libgenbase = (Debug *)libgendata->d_buf;
	size_t libgencount = libgendata->d_size/sizeof(Debug);
	Elf64_Shdr *libgenshdr = elf64_getshdr(libgen);
	printf("Section .psp_libgen_markfunc start in memory at %08X\n",libgenshdr->sh_addr);
	printf("Section .psp_libgen_markfunc start at file offset %08X\n",libgenshdr->sh_offset);
	printf("Number of imports on .psp_libgen_markfunc  %zu\n",libgencount);
		
	Elf_Scn *stubsection = getSection(elf,".lib.stub");
	Elf_Data *stubdata = elf_getdata(stubsection,NULL);
	Stub *stubbase = (Stub *)stubdata->d_buf;
	size_t stubcount = stubdata->d_size/sizeof(Stub);
	Elf64_Shdr *stubshdr = elf64_getshdr(stubsection);
	printf("Number of stubs on .lib.stub  %zu\n",stubcount);
	printf("Section .lib.stub starts in memory at %08X\n",stubshdr->sh_addr);
	printf("Section .lib.stub starts at file offset %08X\n",stubshdr->sh_offset);
	
	Elf_Scn *sceFNId=getSection(elf,".rodata.sceFNID");
	Elf_Data *sceFNIddata=elf_getdata(sceFNId,NULL);
	uint32_t *sceFNIdbase = sceFNIddata->d_buf;
	Elf64_Shdr *fnidshdr = elf64_getshdr(sceFNId);
	printf("Section .rodata.sceFNID starts in memory at 0x%08X \n", fnidshdr->sh_addr);
	printf("Section .rodata.sceFNID starts at file offset 0x%08X \n", fnidshdr->sh_offset);
	//	printf("Section .rodata.sceFNID ends at offset 0x%08X \n", fnidshdr->sh_addr + fnidshdr->sh_size);
		
	Elf_Scn *sceResident=getSection(elf,".rodata.sceResident");
	Elf_Data *sceResidentdata=elf_getdata(sceResident,NULL);
	uint8_t *sceResidentbase = (uint8_t *)sceResidentdata->d_buf;
	size_t sceResidentcount = sceResidentdata->d_size;
	Elf64_Shdr *sceResidentshdr = elf64_getshdr(sceResident);
	printf("Number of bytes on .rodata.sceResident  %zu %d\n",sceResidentcount,sizeof(SceResident));
	printf("Section .rodata.sceResident starts in memory at 0x%08X \n", sceResidentshdr->sh_addr);
	printf("Section .rodata.sceResident starts at file offset 0x%08X \n", sceResidentshdr->sh_offset);
		
	uint32_t ref_lib=0;
	uint32_t actual_lib=0;
	uint32_t import_count=0;
	uint32_t actual_fnid=0;
	uint16_t fnidcount=0;
	uint32_t aux=0;
		
	//we need to fix entries in .rodata.sceFNID
	//we need to fix import(counts),fnid,and stub in .lib.stub
	for(Debug *debug = libgenbase;debug<libgenbase+libgencount;debug++)
	{
		actual_lib=BE32(debug->stub_head);
		Stub *actual_stub=&stubbase[((actual_lib-stubshdr->sh_addr)/sizeof(Stub))];
			
		if(actual_lib==ref_lib)
		{
			import_count++;
					
			if(actual_fnid==libgencount-1)
			{
				printf("import count %d\n",import_count);
				printf("Fixing count in stub 0x%08X to 0x%08X\n",BE16(actual_stub->imports),import_count);		
				lseek(fd,stubshdr->sh_offset + (actual_stub - stubbase)*sizeof(Stub)+offsetof(Stub,imports),SEEK_SET);
				fnidcount=BE16(import_count);
				if(write(fd,&fnidcount,sizeof(fnidcount))!=sizeof(fnidcount)) {
					printf("Error occurred during write in %s:%d\n",__FILE__,__LINE__);
				}
			}
									
		}
		else
		{
			if(import_count!=0 )
			{
				Stub *ref_stub=&stubbase[((ref_lib-stubshdr->sh_addr)/sizeof(Stub))];
				printf("import count %d\n",import_count);
				printf("Fixing count in stub 0x%08X to 0x%08X\n",BE16(ref_stub->imports),import_count);
				lseek(fd,stubshdr->sh_offset + (ref_stub - stubbase)*sizeof(Stub)+offsetof(Stub,imports),SEEK_SET);
				fnidcount=BE16(import_count);
				if(write(fd,&fnidcount,sizeof(fnidcount))!=sizeof(fnidcount)) {
					printf("Error occurred during write in %s:%d\n",__FILE__,__LINE__);
				}
			}
			ref_lib=actual_lib;
			printf("Lib %s \n",sceResidentbase+(BE32(actual_stub->name)-sceResidentshdr->sh_addr));
			printf("Fixing stub\n");
			printf("Fixing stub fnid actual 0x%08X new 0x%08X \n",BE32(actual_stub->fnid),fnidshdr->sh_addr+actual_fnid*4);
			lseek(fd,stubshdr->sh_offset + (actual_stub - stubbase)*sizeof(Stub)+offsetof(Stub,fnid),SEEK_SET);
			aux=BE32(fnidshdr->sh_addr+actual_fnid*4);
			if(write(fd,&aux,sizeof(aux))!=sizeof(aux)) {
				printf("Error occurred during write in %s:%d\n",__FILE__,__LINE__);
			}
			printf("Fixing stub stub actual 0x%08X new 0x%08X \n",BE32(actual_stub->stub),BE32(debug->name));
			lseek(fd,stubshdr->sh_offset + (actual_stub - stubbase)*sizeof(Stub)+offsetof(Stub,stub),SEEK_SET);
			aux=debug->name;
			if(write(fd,&aux,sizeof(aux))!=sizeof(aux)) {
				printf("Error occurred during write in %s:%d\n",__FILE__,__LINE__);
			}
			import_count=1;
		}
		printf("fnid %d: %08lx\n",import_count,BE32(debug->fnid));
		printf("fix on .rodata.sceFNID position  %d 0x%08X\n",actual_fnid,(fnidshdr->sh_addr+actual_fnid*4));
		lseek(fd,fnidshdr->sh_offset + actual_fnid*4,SEEK_SET);
		aux=debug->fnid;
		if(write(fd,&aux,sizeof(aux))!=sizeof(aux)) {
			printf("Error occurred during write in %s:%d\n",__FILE__,__LINE__);
		}
		actual_fnid++;
			
	}
	//Finally we need to change the section name from .psp_libgen_markfunc to .debug_libgenfunc
	size_t shstrndx;
	Elf_Scn *shstrtab = getSection(elf,".shstrtab");
	Elf_Data *shstrtabdata = elf_getdata(shstrtab,NULL);
	char *shstrtabbase = (char *)shstrtabdata->d_buf;
	Elf64_Shdr *shstrtabshdr = elf64_getshdr(shstrtab);
	printf("%d\n",libgenshdr->sh_name);
	char newname[]=".debug_libgenfunc";
	printf("nombre %s %d\n",shstrtabbase+libgenshdr->sh_name,sizeof(".debug_libgenfunc"));
	lseek(fd,shstrtabshdr->sh_offset + libgenshdr->sh_name ,SEEK_SET);
	if(write(fd,newname,sizeof(".debug_libgenfunc"))!=sizeof(".debug_libgenfunc")) {
		printf("Error occurred during write in %s:%d\n",__FILE__,__LINE__);
	}
		
	
	
	elf_end(elf);
	close(fd);

	return 0;
	
}